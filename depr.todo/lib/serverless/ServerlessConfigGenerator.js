/**
 * Defines the ServerlessConfigGenerator class.
 *
 * @author Luke Chavers <luke@c2cschools.com>
 * @author Kevin Sanders <kevin@c2cschools.com>
 * @since 5.1.15
 * @license See LICENSE.md for details about licensing.
 * @copyright 2017 C2C Schools, LLC
 */

"use strict";

const BaseGenerator = require( "../util/BaseGenerator" );

/**
 * This class is used for the automatic generation of a Serverless config file
 * which is consumed by Serverless during the deployment of services and other
 * Serverless Framework powered operations.
 *
 * @memberOf Serverless
 * @extends Util.BaseGenerator
 */
class ServerlessConfigGenerator extends BaseGenerator {

	// noinspection JSMethodCanBeStatic
	/**
	 * Defines a static mapping that this generator uses to create each part of
	 * the exported Serverless config. This variable/property is used,
	 * exclusively, by the `configExports` property.
	 *
	 * @see configExports
	 * @private
	 * @type {Object}
	 * @readonly
	 */
	get _configMethodMap() {

		return [
			{
				property   : "custom",
				methodName : "buildCustomConfig",
			},
			{
				property   : "package",
				methodName : "buildPackageConfig",
			},
			{
				property   : "plugins",
				methodName : "buildPluginsConfig",
			},
			{
				property   : "provider",
				methodName : "buildProviderConfig",
			},
			{
				property   : "functions",
				methodName : "buildFunctionsConfig",
			},
		];
	}

	/**
	 * The object that should be exported by implementing scripts in order to
	 * allow the Serverless Framework access to the configuration data generated
	 * by this generator.
	 *
	 * @example
	 *     ```
	 *     module.exports = configGenerator.configExports;
	 *     ```
	 *
	 * @see https://serverless.com/framework/docs/providers/aws/guide/variables/#reference-variables-in-javascript-files
	 * @public
	 * @type {Object}
	 * @readonly
	 */
	get configExports() {

		const me = this;

		// Dependencies
		const _ = me.$dep( "lodash" );

		let fnMap = me._configMethodMap;

		// Init Return
		let ret = {};

		// Create each export property
		_.each( fnMap, function ( mapping ) {

			ret[ mapping.property ] = me[ mapping.methodName ].bind( me );
		} );

		// Finished
		return ret;
	}

	/**
	 * A debugging function that can be used to dump the configuration data that
	 * is being generated by this config generator.
	 *
	 * @public
	 * @returns {void}
	 */
	dumpConfigExports() {

		const me = this;

		// Dependencies
		const _ = me.$dep( "lodash" );

		let resolvedConfig = {};

		// Create a "DebugHelper"...
		let deb = me.$spawn( "commonLib", "util/DebugHelper" );

		// Resolve all config data...
		_.each( me.configExports, function ( val, key ) {

			if ( _.isFunction( val ) ) {

				resolvedConfig[ key ] = val();

			} else {

				resolvedConfig[ key ] = val;
			}
		} );

		// Dump the config data
		deb.dbg( resolvedConfig, true, 1 );
	}

	/**
	 * Generates the entire serverless config and returns it as an object.
	 *
	 * @returns {Promise<Object>} Serverless config.
	 */
	buildConfig() {

		const me = this;

		// Dependencies
		const BB = me.$dep( "bluebird" );

		return BB.props( {
			service   : me.buildServiceConfig(),
			provider  : me.buildProviderConfig(),
			package   : me.buildPackageConfig(),
			plugins   : me.buildPluginsConfig(),
			custom    : me.buildCustomConfig(),
			functions : me.buildFunctionsConfig(),
		} );
	}

	/**
	 * A specialist method that generates the 'service:' portion of the
	 * Serverless config (`serverless.yml`).
	 *
	 * This method will simply load a common Serverless config file
	 * (e.g. `serverless/config/default/provider.yml`) and return it.
	 *
	 * @public
	 * @returns {Object} The 'service:' portion of the Serverless config.
	 */
	buildServiceConfig() {

		const me = this;

		return {
			name: me.serviceName,
		};
	}

	/**
	 * A specialist method that generates the 'custom:' portion of the
	 * Serverless config (`serverless.yml`).
	 *
	 * This method will simply load a common Serverless config file
	 * (e.g. `serverless/config/default/custom.yml`) and return it.
	 *
	 * Note: Although, in theory, this type of 'common config loading' could be
	 * skipped using the `${file:...}` syntax that Serverless allows, the
	 * specific, absolute, path is not always known to Serverless. So, this
	 * generator allows the Node.js `require` function to assist in the
	 * resolution of paths...
	 *
	 * @public
	 * @returns {Object} The 'custom:' portion of the Serverless config.
	 */
	buildCustomConfig() {

		const me = this;

		return me._loadCommonConfigFile( "custom.yml", "custom" );
	}

	/**
	 * A specialist method that generates the 'plugins:' portion of the
	 * Serverless config (`serverless.yml`).
	 *
	 * This method will simply load a common Serverless config file
	 * (e.g. `serverless/config/default/plugins.yml`) and return it.
	 *
	 * See the note in {@link Serverless#buildCustomConfig} which also applies
	 * to this method.
	 *
	 * @public
	 * @returns {Object} The 'plugins:' portion of the Serverless config.
	 */
	buildPluginsConfig() {

		const me = this;

		return me._loadCommonConfigFile( "plugins.yml", "plugins" );
	}

	/**
	 * A specialist method that generates the 'package:' portion of the
	 * Serverless config (`serverless.yml`).
	 *
	 * This method will simply load a common Serverless config file
	 * (e.g. `serverless/config/default/package.yml`) and return it.
	 *
	 * See the note in {@link Serverless#buildCustomConfig} which also applies
	 * to this method.
	 *
	 * @public
	 * @returns {Object} The 'package:' portion of the Serverless config.
	 */
	buildPackageConfig() {

		const me = this;

		return me._loadCommonConfigFile( "package.yml", "package" );
	}

	/**
	 * A specialist method that generates the 'provider:' portion of the
	 * Serverless config (`serverless.yml`).
	 *
	 * This method will load a common Serverless config file
	 * (e.g. `serverless/config/default/provider.yml`) and then apply decrypted
	 * environment variables from KmsCrypt to the provider object and return it.
	 *
	 * See the note in {@link Serverless#buildCustomConfig} which also applies
	 * to this method.
	 *
	 * @public
	 * @returns {Object} The 'provider:' portion of the Serverless config.
	 */
	buildProviderConfig() {

		const me = this;

		// Dependencies
		const _			= me.$dep( "lodash" );
		const BB		= me.$dep( "bluebird" );
		const YAML		= me.$dep( "js-yaml" );
		const KmsCrypt	= me.$dep( "util/kms-crypt" );

		let providerConfig;

		return BB.try( function () {

			return me._loadCommonConfigFile( "provider.yml", "provider" );

		} ).then( function ( _providerConfig ) {

			providerConfig = _providerConfig;

			return KmsCrypt.decryptFromS3( me.kmsCryptConfig );

		} ).then( function ( decryptedData ) {

			let config = YAML.safeLoad( decryptedData );

			// TODO: determine correct deployment environment (production/development).
			let deploymentEnvironment = "production";

			_.assign( providerConfig.environment, config[ deploymentEnvironment ].environment );

			return providerConfig;
		} );
	}

	/**
	 * A specialist method that generates the 'functions:' portion of the
	 * Serverless config (`serverless.yml`).
	 *
	 * This method will concatenate the function configuration data, defined
	 * in each endpoint's `config/serverless-function.yml` file, from
	 * all endpoints in the target service and return the resulting object.
	 *
	 * @public
	 * @returns {Object} The 'functions:' portion of the Serverless config.
	 */
	buildFunctionsConfig() {

		const me = this;

		// Dependencies
		const _ = me.$dep( "lodash" );

		// Build information about all endpoints
		// in the target service...
		let eps = me.getServiceEndpoints();

		// Init the return object
		let ret = {};

		// Iterate over each endpoint and add its
		// function config to the return
		_.each( eps, function ( epData, epName ) {

			ret[ epName ] = epData.functionConfig;
		} );

		// All done
		return ret;
	}
}

module.exports = ServerlessConfigGenerator;
